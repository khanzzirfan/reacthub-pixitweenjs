{"version":3,"file":"PixiVideoCanvasSync-7a47deea.js","sources":["../../src/hooks/useDebouncePointerEvents.tsx","../../src/components/PixiVideoSprite/PixiVideoSprite.tsx","../../src/components/PixiVideoSprite/PixiVideoCanvasSync.tsx"],"sourcesContent":["import { useCallback } from \"react\";\r\n// @ts-ignore\r\nimport debounce from \"lodash/debounce\";\r\n\r\nconst useDebouncedPointerEvents = (\r\n  onPointerOver: () => void,\r\n  onPointerDown: () => void,\r\n  onPointerOut: () => void,\r\n  delay: number\r\n) => {\r\n  const debouncedPointerOver = useCallback(debounce(onPointerOver, delay), [\r\n    onPointerOver,\r\n    delay,\r\n  ]);\r\n\r\n  const debouncedPointerDown = useCallback(debounce(onPointerDown, delay), [\r\n    onPointerDown,\r\n    delay,\r\n  ]);\r\n\r\n  const debouncedPointerOut = useCallback(debounce(onPointerOut, delay), [\r\n    onPointerOut,\r\n    delay,\r\n  ]);\r\n\r\n  const handlePointerOver = useCallback(() => {\r\n    debouncedPointerOver();\r\n  }, [debouncedPointerOver]);\r\n\r\n  const handlePointerDown = useCallback(() => {\r\n    debouncedPointerDown();\r\n  }, [debouncedPointerDown]);\r\n\r\n  const handlePointerOut = useCallback(() => {\r\n    debouncedPointerOut();\r\n  }, [debouncedPointerOut]);\r\n\r\n  return {\r\n    onPointerOver: handlePointerOver,\r\n    onPointerDown: handlePointerDown,\r\n    onPointerOut: handlePointerOut,\r\n  };\r\n};\r\n\r\nexport default useDebouncedPointerEvents;\r\n","import * as React from \"react\";\nimport { useContext, useEffect, useRef } from \"react\";\n// @ts-ignore\nimport PropTypes from \"prop-types\";\nimport { useCustomEventListener } from \"../../events\";\nimport {\n  GsapPixieContext,\n  Events,\n} from \"../../providers/GsapPixieContextProvider\";\nimport { Sprite, Container } from \"@pixi/react\";\nimport * as PIXI from \"pixi.js\";\nimport gsap from \"gsap\";\nimport AbstractContainer from \"../../hocs/AbstractContainer\";\n// @ts-ignore\nimport isEmpty from \"lodash/isEmpty\";\n// @ts-ignore\nimport debounce from \"lodash/debounce\";\nimport {\n  PixiBaseSpriteProps,\n  ForwardedRefResponse,\n} from \"../../types/BaseProps\";\nimport { withFiltersHook } from \"../../hooks/withFiltersHook\";\nimport useDebouncedPointerEvents from \"../../hooks/useDebouncePointerEvents\";\n\nexport interface PixiVideoSpriteProps extends PixiBaseSpriteProps {\n  uniqueId: string;\n  src: string;\n  frameStartAt: number;\n  frameEndAt: number;\n  mute: boolean;\n  locked: boolean;\n  pointerdown?: () => void;\n  pointerup?: () => void;\n  mousedown?: () => void;\n  mouseup?: () => void;\n  pointerover?: () => void;\n  mouseover?: () => void;\n  mouseout?: () => void;\n  applyTransformer?: boolean;\n  onAnchorTransformationEnd?: (endData: any) => void;\n}\n\ninterface VideoState {\n  isPlaying: boolean;\n  progress: number;\n  speed: number;\n  isMuted: boolean;\n  isWaiting: boolean;\n  isStalled: boolean;\n  loaded: boolean;\n  size: { width: number; height: number };\n  isDragging: boolean;\n  timeDiff: number;\n}\n\nconst initialState: VideoState = {\n  isPlaying: false,\n  progress: 0,\n  speed: 1,\n  isMuted: false,\n  isWaiting: false,\n  isStalled: false,\n  loaded: false,\n  size: { width: 50, height: 50 },\n  isDragging: false,\n  timeDiff: 0,\n};\n\nconst PixiVideoSprite = React.forwardRef<\n  ForwardedRefResponse | null,\n  PixiVideoSpriteProps\n>((props, ref) => {\n  //// State\n  const [updater, setUpdater] = React.useState<number>(0);\n  const [videoTexture, setVideoTexture] =\n    React.useState<PIXI.Texture<PIXI.Resource>>();\n\n  //// Refs\n  const imageRef = useRef<PIXI.Sprite>(null);\n  const containerRef = useRef<PIXI.Container>(null);\n  const videoElement = useRef<HTMLVideoElement>(null);\n  const videoStateRef = useRef<VideoState>(initialState);\n  const tweenRef = useRef<gsap.core.Tween>();\n\n  /// 1001\n  // console.log(\"contxt Values\", tl);\n  const {\n    uniqueId,\n    mute = false,\n    src,\n    startAt,\n    endAt,\n    frameStartAt,\n    frameEndAt,\n    visible,\n    disabled,\n    transformation: { x, y, width, height, animation, colorCorrection = {} },\n    pointerdown = () => void 0,\n    pointerout = () => void 0,\n    pointerover = () => void 0,\n    fps = 0,\n  } = props;\n\n  //// Context\n  const { tl, dragModeRef, isRemotion } = useContext(GsapPixieContext);\n\n  /// hooks;\n  const { onPointerDown, onPointerOut, onPointerOver } =\n    useDebouncedPointerEvents(pointerover, pointerdown, pointerout, 1);\n\n  const { blurRadius = 0, vignette = 0, noise = 0 } = colorCorrection;\n  // use with filters hoooks to get the filters\n  const {\n    temperatureFilter,\n    sharpnessFilter,\n    hueFilter,\n    blurFilter,\n    adjustmentFilter,\n    vignetteFilter,\n    noiseFilter,\n  } = withFiltersHook(colorCorrection);\n\n  const videoUrl = src || \"\";\n\n  /**Adding this alternative workaround to work with mov/mk4 video types */\n  const videoSrcElement = React.useMemo(() => {\n    const element = document.createElement(\"video\");\n    element.src = src;\n    element.crossOrigin = \"Anonymus\";\n    element.autoplay = false;\n    element.currentTime = frameStartAt === 0 ? 0.001 : frameStartAt;\n    return element;\n  }, [src, frameStartAt]);\n\n  /** Adding custom event listners */\n  /** Event Listeneres */\n  useCustomEventListener(Events.PAUSE, () => {\n    if (videoElement.current) {\n      videoElement.current.pause();\n      videoStateRef.current.isPlaying = false;\n    }\n  });\n\n  useCustomEventListener(Events.SCRUBBER_CLICKED, () => {\n    if (videoElement.current) {\n      videoElement.current.pause();\n      videoStateRef.current.isPlaying = false;\n    }\n  });\n\n  // reset timeline when reverse mode end.\n  useCustomEventListener(Events.REVERSE_MODE_END, () => {\n    if (videoElement.current) {\n      videoElement.current.pause();\n      videoStateRef.current.isPlaying = false;\n    }\n  });\n\n  /** Debounce pause video */\n  const pauseVideoDebounce = React.useCallback(\n    debounce(() => {\n      if (videoElement.current) {\n        const vid = videoElement.current;\n        const isVidPlaying =\n          vid.currentTime > 0 &&\n          !vid.paused &&\n          !vid.ended &&\n          vid.readyState > vid.HAVE_CURRENT_DATA;\n        if (isVidPlaying) videoElement.current.pause();\n        videoStateRef.current.isPlaying = false;\n      }\n    }, 400),\n    [videoElement]\n  );\n\n  // /** stop video playing when gsapDragging is true */\n  React.useEffect(() => {\n    if (videoElement.current && !isRemotion) {\n      if (dragModeRef.current) {\n        pauseVideoDebounce();\n        videoStateRef.current.isPlaying = false;\n        videoStateRef.current.isDragging = true;\n      } else {\n        videoStateRef.current.isDragging = false;\n      }\n      videoElement.current.muted = mute;\n    } else {\n      videoStateRef.current.isDragging = false;\n    }\n    videoStateRef.current.isMuted = mute;\n  }, [mute, dragModeRef, pauseVideoDebounce, videoElement]);\n\n  /** Gsap Start and Stop Events */\n  const gsapOnStart = (frameStartAt: number) => {\n    if (videoElement.current) {\n      // console.log(\"video gsapOnStart\", playerTimeRef.current, gsapDragging);\n      // const roundedPlayerTime = Number(Math.round(playerTimeRef.current));\n      // check the start and end times are between the playerTimeRef.current to start video;\n      videoElement.current.currentTime = Number(frameStartAt);\n      if (!dragModeRef.current) {\n        const vid = videoElement.current;\n        const isVidPlaying =\n          vid.currentTime > 0 &&\n          !vid.paused &&\n          !vid.ended &&\n          vid.readyState > vid.HAVE_CURRENT_DATA;\n        if (\n          tl.current &&\n          tl.current.isActive() &&\n          tweenRef.current &&\n          tweenRef.current.isActive()\n        ) {\n          if (!isVidPlaying) videoElement.current.play();\n          videoStateRef.current.isPlaying = true;\n          setUpdater((prev) => prev + 1);\n        }\n      }\n      videoStateRef.current.progress = 0;\n    }\n  };\n\n  const gsapOnComplete = () => {\n    if (videoElement.current) {\n      const vid = videoElement.current;\n      const isVidPlaying =\n        vid.currentTime > 0 &&\n        !vid.paused &&\n        !vid.ended &&\n        vid.readyState > vid.HAVE_CURRENT_DATA;\n      ///if (!isVidPlaying) videoElement.current.play();\n      if (isVidPlaying) videoElement.current.pause();\n      videoStateRef.current.isPlaying = false;\n      if (tweenRef.current) {\n        videoStateRef.current.progress = tweenRef.current.progress();\n      }\n    }\n  };\n\n  const onInterrupt = () => {\n    // console.log('interrupting', refId);\n  };\n\n  const onUpdate = () => {\n    if (tweenRef.current) {\n      videoStateRef.current.progress = tweenRef.current.progress();\n    }\n\n    if (videoElement.current && tweenRef.current) {\n      const currentTweenTime = frameStartAt + tweenRef?.current?.time();\n      // console.log(\n      //   \"currenttime vs player reftime\",\n      //   videoElement.current.currentTime,\n      //   playerTimeRef.current\n      // );\n      const absDiff = Math.abs(\n        videoElement.current.currentTime - currentTweenTime\n      );\n\n      const vid = videoElement.current;\n      const isVidPlaying =\n        vid.currentTime > 0 &&\n        !vid.paused &&\n        !vid.ended &&\n        vid.readyState > vid.HAVE_CURRENT_DATA;\n\n      if (dragModeRef.current) {\n        /// console.log(\"is videoStateRef.current.isDragging state in drag mode\");\n        videoElement.current.currentTime = currentTweenTime;\n        setTimeout(() => {\n          if (videoElement.current) {\n            videoElement.current.play().then(() => {\n              videoStateRef.current.isPlaying = false;\n              if (videoElement.current) videoElement.current.pause();\n            });\n          }\n        }, 100);\n        videoStateRef.current.isPlaying = false;\n      } else if (\n        (isVidPlaying !== videoStateRef.current.isPlaying || !isVidPlaying) &&\n        videoStateRef.current.progress > 0.01 &&\n        videoStateRef.current.progress < 0.99\n      ) {\n        if (\n          tl.current?.isActive() &&\n          tweenRef.current &&\n          tweenRef.current.isActive()\n        ) {\n          if (!isVidPlaying) videoElement.current.play();\n          videoStateRef.current.isPlaying = true;\n        }\n      } else if (\n        absDiff > 0.3 &&\n        videoStateRef.current.progress > 0.01 &&\n        videoStateRef.current.progress < 0.99\n      ) {\n        videoElement.current.currentTime = currentTweenTime;\n        // if (!isVidPlaying) videoElement.current.play();\n        // videoStateRef.current.isPlaying = true;\n      }\n    }\n  };\n\n  useEffect(() => {\n    let ctx = gsap.context(() => {});\n    if (containerRef.current && tl.current) {\n      const data = {\n        duration: Number(frameEndAt) - Number(frameStartAt),\n        onStart: gsapOnStart,\n        onComplete: gsapOnComplete,\n        onStartParams: [frameStartAt, frameEndAt],\n        onCompleteParams: [],\n        onInterrupt: onInterrupt,\n        onUpdate: onUpdate,\n        onUpdateParams: [frameStartAt, frameEndAt],\n        onPause: () => {\n          console.log(\"onPause video sprite pause\", uniqueId);\n        },\n        onResume: () => {\n          console.log(\"onResume video sprite resume\", uniqueId);\n        },\n        onReverseComplete: () => {\n          console.log(\n            \"onReverseComplete video sprite reverse complete\",\n            uniqueId\n          );\n        },\n        onKill: () => {\n          console.log(\"onKill video sprite kill\", uniqueId);\n        },\n      };\n\n      // kill tween before adding it.\n      ctx = gsap.context(() => {\n        tweenRef.current = gsap.from(\n          containerRef.current,\n          // @ts-ignore\n          data,\n          frameStartAt\n        );\n        tl.current.add(tweenRef.current, startAt);\n      });\n    }\n    return () => {\n      if (tweenRef.current) {\n        tweenRef.current.kill();\n        gsap.killTweensOf(tweenRef.current);\n      }\n      ctx.revert(); // cleanup!\n    };\n  }, [animation, startAt, endAt, frameStartAt, frameEndAt]);\n\n  React.useEffect(() => {\n    if (videoElement.current) {\n      videoElement.current.muted = mute;\n      videoStateRef.current.isMuted = mute;\n    }\n    // sometimes the videoElement is not ready so we need to wait for it to be ready\n    const timeoutId = setTimeout(() => {\n      if (videoElement.current) {\n        videoElement.current.muted = mute;\n        videoStateRef.current.isMuted = mute;\n      }\n    }, 1500);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [mute]);\n\n  // load // load meta // load seek through\n  React.useEffect(() => {\n    const minStartAt =\n      Math.round((Number(frameStartAt) + Number.EPSILON) * 100) / 100;\n    const onload = function () {\n      if (videoElement.current) {\n        videoElement.current.currentTime = minStartAt;\n        videoElement.current.muted = mute;\n      }\n    };\n\n    const onEnd = function () {\n      //dispatchState({ isPlaying: false });\n      if (videoElement.current) {\n        const vid = videoElement.current;\n        const isVidPlaying =\n          vid.currentTime > 0 &&\n          !vid.paused &&\n          !vid.ended &&\n          vid.readyState > vid.HAVE_CURRENT_DATA;\n\n        if (isVidPlaying) {\n          videoElement.current.pause();\n        }\n      }\n      videoStateRef.current.isWaiting = false;\n      videoStateRef.current.isStalled = false;\n    };\n\n    const onLoadStart = function () {\n      //dispatchState({ isWaiting: true, isStalled: false });\n      if (videoElement.current) {\n        videoElement.current.pause();\n      }\n\n      videoStateRef.current.isWaiting = true;\n      videoStateRef.current.isStalled = false;\n    };\n\n    const onCanPlayThrough = function () {\n      //dispatchState({ isWaiting: false, isStalled: false });\n      videoStateRef.current.isWaiting = false;\n      videoStateRef.current.isStalled = false;\n    };\n\n    const onStalled = function () {\n      //dispatchState({ isStalled: true });\n      //setVideoState({ isWaiting: false, isStalled: true });\n      videoStateRef.current.isWaiting = false;\n      videoStateRef.current.isStalled = true;\n    };\n\n    // create a new Sprite using the video texture (yes it's that easy)\n    const stAt =\n      Math.round((Number(frameStartAt) + Number.EPSILON) * 100) / 100;\n    const endAt = Math.round((Number(frameEndAt) + Number.EPSILON) * 100) / 100;\n    const urlWithTimestamp = `${videoUrl}#t=${stAt},${endAt}`;\n    /// const urlWithQuery = `${videoUrl}?t=${stAt},${endAt}`;\n\n    /// const texture =\n    PIXI.Texture.fromLoader(videoSrcElement, urlWithTimestamp, uniqueId, {\n      pixiIdPrefix: uniqueId,\n      resourceOptions: {\n        autoPlay: false,\n        crossorigin: \"Anonymus\",\n        updateFPS: fps ? Math.max(120, Number(fps)) : 30,\n      },\n    }).then((texture) => {\n      if (!texture) return;\n      // texture.baseTexture.resource.source.currentSrc = urlWithTimestamp;\n      setVideoTexture(texture);\n\n      // @ts-ignore\n      videoElement.current = texture.baseTexture.resource.source;\n      // @ts-ignore\n      videoElement.current.id = uniqueId;\n      // @ts-ignore\n      videoElement.current.addEventListener(\"loadedmetadata\", onload);\n      // @ts-ignore\n      videoElement.current.addEventListener(\"ended\", onEnd);\n      // @ts-ignore\n      videoElement.current.addEventListener(\"loadstart\", onLoadStart);\n      // @ts-ignore\n      videoElement.current.addEventListener(\"canplaythrough\", onCanPlayThrough);\n      // @ts-ignore\n      videoElement.current.addEventListener(\"stalled\", onStalled);\n    });\n\n    return () => {\n      if (videoElement.current) {\n        videoElement.current.pause();\n        videoElement.current.removeEventListener(\"loadedmetadata\", onload);\n        videoElement.current.removeEventListener(\"ended\", onEnd);\n        videoElement.current.removeEventListener(\"loadstart\", onLoadStart);\n        videoElement.current.removeEventListener(\n          \"canplaythrough\",\n          onCanPlayThrough\n        );\n        videoElement.current.removeEventListener(\"stalled\", onStalled);\n        /** unmount it completely */\n        // Stop and remove the video element when the component unmounts\n      }\n    };\n    // create a new Sprite using the video texture (yes it's that easy)\n    // const videoSprite = new PIXI.Sprite(texture);\n  }, [videoUrl, uniqueId, frameStartAt, frameEndAt, videoSrcElement]);\n\n  // Add use effect when the video texture is loaded for the first time\n  React.useEffect(() => {\n    /// run the timeout for checking it all below logic\n    const timeoutId = setTimeout(() => {\n      if (videoTexture && tweenRef.current && tl.current) {\n        const tweenCurrentProgress = tweenRef.current.progress();\n        if (\n          tweenCurrentProgress < 0.1 &&\n          videoElement.current &&\n          !tweenRef.current.isActive() &&\n          !isRemotion\n        ) {\n          videoElement.current.play().then(() => {\n            videoStateRef.current.isPlaying = false;\n            if (videoElement.current) videoElement.current.pause();\n          });\n        }\n      }\n    }, 30);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [videoTexture]);\n\n  /** ON start use effect to check if the timeline is really in progress else stop playing */\n  React.useEffect(() => {\n    // inactivate if timeline is inactive\n    if (tl.current && !tl.current.isActive() && !isRemotion) {\n      videoStateRef.current.isPlaying = false;\n      if (videoElement.current) videoElement.current.pause();\n    }\n\n    const timeoutId = setTimeout(() => {\n      if (videoTexture && tl.current && updater > 0 && !isRemotion) {\n        if (!tl.current.isActive()) {\n          videoStateRef.current.isPlaying = false;\n          if (videoElement.current) videoElement.current.pause();\n        }\n        const vid = videoElement.current;\n        if (\n          vid &&\n          tl.current.isActive() &&\n          tweenRef.current &&\n          tweenRef.current.isActive()\n        ) {\n          const isVidPlaying =\n            vid.currentTime > 0 &&\n            !vid.paused &&\n            !vid.ended &&\n            vid.readyState > vid.HAVE_CURRENT_DATA;\n          if (!isVidPlaying) videoElement.current.play();\n          videoStateRef.current.isPlaying = true;\n        }\n        /// videoStateRef.current.progress = tweenRef.current.progress();\n      }\n    }, 10);\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [updater, videoTexture]);\n\n  return (\n    <AbstractContainer\n      {...props}\n      ref={ref}\n      ignoreTlForVideo={true}\n      pointerdown={onPointerDown}\n      pointerover={onPointerOver}\n      pointerout={onPointerOut}\n    >\n      {/* @ts-ignore */}\n      <Container ref={containerRef}>\n        {videoTexture && (\n          <Sprite\n            texture={videoTexture}\n            width={width}\n            height={height}\n            anchor={0.5}\n            x={x}\n            y={y}\n            ref={imageRef}\n            alpha={visible ? 1 : 0}\n            {...(!disabled &&\n              visible && { interactive: true, pointerdown: pointerdown })}\n            filters={[\n              temperatureFilter,\n              sharpnessFilter,\n              hueFilter,\n              adjustmentFilter,\n              // conditionally add blur filter\n              ...(blurRadius > 0 ? [blurFilter] : []),\n              // conditionally add vignette filter\n              ...(vignette > 0 ? [vignetteFilter] : []),\n              // conditionally add noise filter\n              ...(noise > 0 ? [noiseFilter] : []),\n            ]}\n          />\n        )}\n      </Container>\n    </AbstractContainer>\n  );\n});\n\nexport default PixiVideoSprite;\n\n// @ts-ignore\nPixiVideoSprite.whyDidYouRender = {\n  logOnDifferentValues: true,\n  customName: \"PixiVideoSprite\",\n};\n","import * as React from \"react\";\r\nimport { useRef } from \"react\";\r\n// @ts-ignore\r\nimport PropTypes from \"prop-types\";\r\nimport { Sprite, Container, useApp, useTick } from \"@pixi/react\";\r\nimport * as PIXI from \"pixi.js\";\r\nimport AbstractContainer from \"../../hocs/AbstractContainer\";\r\n// @ts-ignore\r\nimport isEmpty from \"lodash/isEmpty\";\r\n// @ts-ignore\r\nimport debounce from \"lodash/debounce\";\r\nimport {\r\n  PixiBaseSpriteProps,\r\n  ForwardedRefResponse,\r\n} from \"../../types/BaseProps\";\r\nimport { withFiltersHook } from \"../../hooks/withFiltersHook\";\r\nimport useDebouncedPointerEvents from \"../../hooks/useDebouncePointerEvents\";\r\n\r\nexport interface CanvasImageProps {\r\n  getCanvas: () => PIXI.TextureSource | PIXI.TextureSource[];\r\n}\r\n\r\nexport interface PixiVideoSpriteProps extends PixiBaseSpriteProps {\r\n  uniqueId: string;\r\n  src: string;\r\n  frameStartAt: number;\r\n  frameEndAt: number;\r\n  mute: boolean;\r\n  locked: boolean;\r\n  pointerdown?: () => void;\r\n  pointerup?: () => void;\r\n  mousedown?: () => void;\r\n  mouseup?: () => void;\r\n  pointerover?: () => void;\r\n  mouseover?: () => void;\r\n  mouseout?: () => void;\r\n  applyTransformer?: boolean;\r\n  onAnchorTransformationEnd?: (endData: any) => void;\r\n  canvasImageRef?: CanvasImageProps;\r\n}\r\n\r\nconst PixiVideoCanvasSyncSprite = React.forwardRef<\r\n  ForwardedRefResponse | null,\r\n  PixiVideoSpriteProps\r\n>((props, ref) => {\r\n  //// State\r\n  const [videoTexture, setVideoTexture] =\r\n    React.useState<PIXI.Texture<PIXI.Resource>>();\r\n\r\n  //// Refs\r\n  const imageRef = useRef<PIXI.Sprite>(null);\r\n  const containerRef = useRef<PIXI.Container>(null);\r\n\r\n  /// 1001\r\n  // console.log(\"contxt Values\", tl);\r\n  const {\r\n    visible,\r\n    disabled,\r\n    transformation: { x, y, width, height, colorCorrection = {} },\r\n    pointerdown = () => void 0,\r\n    pointerout = () => void 0,\r\n    pointerover = () => void 0,\r\n    canvasImageRef,\r\n  } = props;\r\n\r\n  const canvasSource = canvasImageRef && canvasImageRef?.getCanvas();\r\n  const app = useApp();\r\n\r\n  /// hooks;\r\n  const { onPointerDown, onPointerOut, onPointerOver } =\r\n    useDebouncedPointerEvents(pointerover, pointerdown, pointerout, 1);\r\n\r\n  const { blurRadius = 0, vignette = 0, noise = 0 } = colorCorrection;\r\n  // use with filters hoooks to get the filters\r\n  const {\r\n    temperatureFilter,\r\n    sharpnessFilter,\r\n    hueFilter,\r\n    blurFilter,\r\n    adjustmentFilter,\r\n    vignetteFilter,\r\n    noiseFilter,\r\n  } = withFiltersHook(colorCorrection);\r\n\r\n  useTick(() => {\r\n    if (imageRef.current) {\r\n      if (imageRef.current.texture) {\r\n        const baseTexture = imageRef.current.texture.baseTexture;\r\n        if (baseTexture) {\r\n          baseTexture.update();\r\n        }\r\n        if (containerRef.current) app.renderer.render(containerRef.current);\r\n      }\r\n    }\r\n  });\r\n\r\n  // load\r\n  React.useEffect(() => {\r\n    // create a new Sprite using the video texture (yes it's that easy)\r\n    if (!isEmpty(canvasSource)) {\r\n      const texture = PIXI.Texture.from(canvasSource!);\r\n      // if (!texture) return;\r\n      setVideoTexture(texture);\r\n    }\r\n    // create a new Sprite using the video texture (yes it's that easy)\r\n    // const videoSprite = new PIXI.Sprite(texture);\r\n  }, [canvasSource]);\r\n\r\n  return (\r\n    <AbstractContainer\r\n      {...props}\r\n      ref={ref}\r\n      ignoreTlForVideo={true}\r\n      pointerdown={onPointerDown}\r\n      pointerover={onPointerOver}\r\n      pointerout={onPointerOut}\r\n    >\r\n      {/* @ts-ignore */}\r\n      <Container ref={containerRef}>\r\n        {videoTexture && (\r\n          <Sprite\r\n            texture={videoTexture}\r\n            width={width}\r\n            height={height}\r\n            anchor={0.5}\r\n            x={x}\r\n            y={y}\r\n            ref={imageRef}\r\n            alpha={visible ? 1 : 0}\r\n            {...(!disabled &&\r\n              visible && { interactive: true, pointerdown: pointerdown })}\r\n            filters={[\r\n              temperatureFilter,\r\n              sharpnessFilter,\r\n              hueFilter,\r\n              adjustmentFilter,\r\n              // conditionally add blur filter\r\n              ...(blurRadius > 0 ? [blurFilter] : []),\r\n              // conditionally add vignette filter\r\n              ...(vignette > 0 ? [vignetteFilter] : []),\r\n              // conditionally add noise filter\r\n              ...(noise > 0 ? [noiseFilter] : []),\r\n            ]}\r\n          />\r\n        )}\r\n      </Container>\r\n    </AbstractContainer>\r\n  );\r\n});\r\n\r\nexport default PixiVideoCanvasSyncSprite;\r\n"],"names":["useDebouncedPointerEvents","onPointerOver","onPointerDown","onPointerOut","delay","debouncedPointerOver","useCallback","debounce","debouncedPointerDown","debouncedPointerOut","handlePointerOver","handlePointerDown","handlePointerOut","initialState","PixiVideoSprite","React.forwardRef","props","ref","updater","setUpdater","React.useState","videoTexture","setVideoTexture","imageRef","useRef","containerRef","videoElement","videoStateRef","tweenRef","uniqueId","mute","src","startAt","endAt","frameStartAt","frameEndAt","visible","disabled","x","y","width","height","animation","colorCorrection","pointerdown","pointerout","pointerover","fps","tl","dragModeRef","isRemotion","useContext","GsapPixieContext","blurRadius","vignette","noise","temperatureFilter","sharpnessFilter","hueFilter","blurFilter","adjustmentFilter","vignetteFilter","noiseFilter","withFiltersHook","videoUrl","videoSrcElement","React.useMemo","element","useCustomEventListener","Events","pauseVideoDebounce","React.useCallback","vid","React.useEffect","gsapOnStart","frameStartAt2","isVidPlaying","prev","gsapOnComplete","onInterrupt","onUpdate","currentTweenTime","_a","absDiff","_b","useEffect","ctx","gsap","data","timeoutId","minStartAt","onload","onEnd","onLoadStart","onCanPlayThrough","onStalled","stAt","endAt2","urlWithTimestamp","PIXI.Texture","texture","jsx","AbstractContainer","Container","Sprite","canvasImageRef","canvasSource","app","useApp","useTick","baseTexture","isEmpty"],"mappings":"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"}